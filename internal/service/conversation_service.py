#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
@File    : conversation_service.py
"""
import logging
from dataclasses import dataclass
from datetime import datetime
from typing import Any
from uuid import UUID

from flask import Flask
from injector import inject
from langchain_core.output_parsers import StrOutputParser
from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI
from sqlalchemy import desc

from internal.core.agent.entities.queue_entity import AgentThought, QueueEvent
from internal.entity.conversation_entity import (
    SUMMARIZER_TEMPLATE,
    CONVERSATION_NAME_TEMPLATE,
    ConversationInfo,
    SUGGESTED_QUESTIONS_TEMPLATE,
    SuggestedQuestions, InvokeFrom, MessageStatus,
)
from internal.exception import NotFoundException
from internal.model import Conversation, Message, MessageAgentThought, Account
from internal.schema.conversation_schema import GetConversationMessagesWithPageReq
from pkg.paginator import Paginator
from pkg.sqlalchemy import SQLAlchemy
from .base_service import BaseService


@inject
@dataclass
class ConversationService(BaseService):
    """Service for handling conversations."""
    db: SQLAlchemy

    @classmethod
    def summary(cls, human_message: str, ai_message: str, old_summary: str = "") -> str:
        """Generate a new summary based on the human message, AI message, and previous summary."""
        prompt = ChatPromptTemplate.from_template(SUMMARIZER_TEMPLATE)
        llm = ChatOpenAI(model="gpt-4o-mini", temperature=0.5)
        summary_chain = prompt | llm | StrOutputParser()

        new_summary = summary_chain.invoke({
            "summary": old_summary,
            "new_lines": f"Human: {human_message}\nAI: {ai_message}",
        })
        return new_summary

    @classmethod
    def generate_conversation_name(cls, query: str) -> str:
        """Generate a conversation name based on the user query. Output language matches the user input."""
        prompt = ChatPromptTemplate.from_messages([
            ("system", CONVERSATION_NAME_TEMPLATE),
            ("human", "{query}")
        ])

        llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)
        structured_llm = llm.with_structured_output(ConversationInfo)

        chain = prompt | structured_llm

        # Truncate excessively long input text
        if len(query) > 2000:
            query = query[:300] + "...[TRUNCATED]..." + query[-300:]
        query = query.replace("\n", " ")

        conversation_info = chain.invoke({"query": query})

        name = "New Conversation"
        try:
            if conversation_info and hasattr(conversation_info, "subject"):
                name = conversation_info.subject
        except Exception as e:
            logging.exception(f"Failed to extract conversation name. Info: {conversation_info}, Error: {e}")

        if len(name) > 75:
            name = name[:75] + "..."

        return name

    @classmethod
    def generate_suggested_questions(cls, histories: str) -> list[str]:
        """Generate up to 3 suggested follow-up questions based on the conversation history."""
        prompt = ChatPromptTemplate.from_messages([
            ("system", SUGGESTED_QUESTIONS_TEMPLATE),
            ("human", "{histories}")
        ])

        llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)
        structured_llm = llm.with_structured_output(SuggestedQuestions)

        chain = prompt | structured_llm
        suggested_questions = chain.invoke({"histories": histories})

        questions = []
        try:
            if suggested_questions and hasattr(suggested_questions, "questions"):
                questions = suggested_questions.questions
        except Exception as e:
            logging.exception(f"Failed to generate suggested questions: {suggested_questions}, Error: {e}")

        return questions[:3]

    def save_agent_thoughts(
            self,
            flask_app: Flask,
            account_id: UUID,
            app_id: UUID,
            app_config: dict[str, Any],
            conversation_id: UUID,
            message_id: UUID,
            agent_thoughts: list[AgentThought],
    ):
        """Store all reasoning steps and events generated by the agent."""
        with flask_app.app_context():
            position = 0
            latency = 0

            conversation = self.get(Conversation, conversation_id)
            message = self.get(Message, message_id)

            for agent_thought in agent_thoughts:
                # Save LTM recall, reasoning, message output, action execution, or dataset retrieval
                if agent_thought.event in [
                    QueueEvent.LONG_TERM_MEMORY_RECALL,
                    QueueEvent.AGENT_THOUGHT,
                    QueueEvent.AGENT_MESSAGE,
                    QueueEvent.AGENT_ACTION,
                    QueueEvent.DATASET_RETRIEVAL,
                ]:
                    position += 1
                    latency += agent_thought.latency

                    self.create(
                        MessageAgentThought,
                        app_id=app_id,
                        conversation_id=conversation.id,
                        message_id=message.id,
                        invoke_from=InvokeFrom.DEBUGGER,
                        created_by=account_id,
                        position=position,
                        event=agent_thought.event,
                        thought=agent_thought.thought,
                        observation=agent_thought.observation,
                        tool=agent_thought.tool,
                        tool_input=agent_thought.tool_input,
                        message=agent_thought.message,
                        message_token_count=agent_thought.message_token_count,
                        message_unit_price=agent_thought.message_unit_price,
                        message_price_unit=agent_thought.message_price_unit,
                        answer=agent_thought.answer,
                        answer_token_count=agent_thought.answer_token_count,
                        answer_unit_price=agent_thought.answer_unit_price,
                        answer_price_unit=agent_thought.answer_price_unit,
                        total_token_count=agent_thought.total_token_count,
                        total_price=agent_thought.total_price,
                        latency=agent_thought.latency,
                    )

                # Handle final message event from the agent
                if agent_thought.event == QueueEvent.AGENT_MESSAGE:
                    self.update(
                        message,
                        message=agent_thought.message,
                        message_token_count=agent_thought.message_token_count,
                        message_unit_price=agent_thought.message_unit_price,
                        message_price_unit=agent_thought.message_price_unit,
                        answer=agent_thought.answer,
                        answer_token_count=agent_thought.answer_token_count,
                        answer_unit_price=agent_thought.answer_unit_price,
                        answer_price_unit=agent_thought.answer_price_unit,
                        total_token_count=agent_thought.total_token_count,
                        total_price=agent_thought.total_price,
                        latency=latency,
                    )

                    # Update LTM summary
                    if app_config["long_term_memory"]["enable"]:
                        new_summary = self.summary(
                            message.query,
                            agent_thought.answer,
                            conversation.summary,
                        )
                        self.update(conversation, summary=new_summary)

                    # Generate a new conversation name if this is the first message
                    if conversation.is_new:
                        new_name = self.generate_conversation_name(message.query)
                        self.update(conversation, name=new_name)

                # Stop or error event
                if agent_thought.event in [QueueEvent.TIMEOUT, QueueEvent.STOP, QueueEvent.ERROR]:
                    self.update(
                        message,
                        status=agent_thought.event,
                        error=agent_thought.observation,
                    )
                    break

    def get_conversation(self, conversation_id: UUID, account: Account) -> Conversation:
        """Retrieve a specific conversation using conversation ID and account"""
        # 1. Query the conversation record by conversation_id
        conversation = self.get(Conversation, conversation_id)
        if (
                not conversation
                or conversation.created_by != account.id
                or conversation.is_deleted
        ):
            raise NotFoundException(
                "The conversation does not exist or has been deleted. Please verify and try again."
            )

        # 2. Validation passed, return the conversation
        return conversation

    def get_message(self, message_id: UUID, account: Account) -> Message:
        """Retrieve a specific message using message ID and account"""
        # 1. Query the message record by message_id
        message = self.get(Message, message_id)
        if (
                not message
                or message.created_by != account.id
                or message.is_deleted
        ):
            raise NotFoundException(
                "The message does not exist or has been deleted. Please verify and try again."
            )

        # 2. Validation passed, return the message
        return message

    def get_conversation_messages_with_page(
            self,
            conversation_id: UUID,
            req: GetConversationMessagesWithPageReq,
            account: Account,
    ) -> tuple[list[Message], Paginator]:
        """Retrieve a paginated list of messages for the given conversation ID under the current account"""
        # 1. Retrieve the conversation and validate permissions
        conversation = self.get_conversation(conversation_id, account)

        # 2. Build paginator and set cursor filters
        paginator = Paginator(db=self.db, req=req)
        filters = []
        if req.created_at.data:
            # 3. Convert timestamp to datetime
            created_at_datetime = datetime.fromtimestamp(req.created_at.data)
            filters.append(Message.created_at <= created_at_datetime)

        # 4. Execute paginated query
        messages = paginator.paginate(
            self.db.session.query(Message).filter(
                Message.conversation_id == conversation.id,
                Message.status.in_([MessageStatus.STOP, MessageStatus.NORMAL]),
                Message.answer != "",
                ~Message.is_deleted,
                *filters,
            ).order_by(desc("created_at"))
        )

        return messages, paginator

    def delete_conversation(self, conversation_id: UUID, account: Account) -> Conversation:
        """Delete a conversation record for the given conversation ID and account"""
        # 1. Retrieve the conversation record and validate permissions
        conversation = self.get_conversation(conversation_id, account)

        # 2. Mark the conversation as deleted
        self.update(conversation, is_deleted=True)

        return conversation

    def delete_message(self, conversation_id: UUID, message_id: UUID, account: Account) -> Message:
        """Delete a message record for the given conversation ID and message ID"""
        # 1. Retrieve the conversation record and validate permissions
        conversation = self.get_conversation(conversation_id, account)

        # 2. Retrieve the message and validate permissions
        message = self.get_message(message_id, account)

        # 3. Verify that the message belongs to the conversation
        if conversation.id != message.conversation_id:
            raise NotFoundException(
                "The specified message does not belong to this conversation. Please verify and try again."
            )

        # 4. Mark the message as deleted
        self.update(message, is_deleted=True)

        return message

    def update_conversation(self, conversation_id: UUID, account: Account, **kwargs) -> Conversation:
        """Update conversation information using conversation ID, account, and keyword arguments"""
        # 1. Retrieve the conversation record and validate permissions
        conversation = self.get_conversation(conversation_id, account)

        # 2. Update conversation fields
        self.update(conversation, **kwargs)

        return conversation
