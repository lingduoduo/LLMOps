#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
@File    : queue_entity.py
"""
from enum import Enum
from uuid import UUID

from pydantic import BaseModel, Field

from internal.entity.conversation_entity import MessageStatus


class QueueEvent(str, Enum):
    """Queue event enumeration type"""
    LONG_TERM_MEMORY_RECALL = "long_term_memory_recall"  # Long-term memory recall event
    AGENT_THOUGHT = "agent_thought"  # Agent reasoning/observation event
    AGENT_MESSAGE = "agent_message"  # Agent message event
    AGENT_ACTION = "agent_action"  # Agent action
    DATASET_RETRIEVAL = "dataset_retrieval"  # Knowledge base retrieval event
    AGENT_END = "agent_end"  # Agent ending event
    STOP = "stop"  # Agent stop event
    ERROR = "error"  # Agent error event
    TIMEOUT = "timeout"  # Agent timeout event
    PING = "ping"  # Connectivity / ping event


class AgentThought(BaseModel):
    """Agent reasoning/observation output"""
    id: UUID  # ID of the event; identical for the same event chain
    task_id: UUID  # Task ID

    # Event reasoning and observation
    event: QueueEvent
    thought: str = ""  # LLM reasoning content
    observation: str = ""  # Observation output

    # Tool-related fields
    tool: str = ""  # Name of the tool invoked
    tool_input: dict = Field(default_factory=dict)  # Tool input arguments

    # Message-related data
    message: list[dict] = Field(default_factory=dict)  # Message list used for reasoning
    message_token_count: int = 0  # Token cost from message context
    message_unit_price: float = 0  # Unit price
    message_price_unit: float = 0  # Price unit

    # Answer-related data
    answer: str = ""  # Final answer generated by the LLM
    answer_token_count: int = 0  # Token count for generated answer
    answer_unit_price: float = 0  # Unit price
    answer_price_unit: float = 0  # Price unit

    # Agent reasoning statistics
    total_token_count: int = 0  # Total token consumption
    total_price: float = 0  # Total cost
    latency: float = 0  # Latency of this step


class AgentResult(BaseModel):
    """Final result of agent reasoning"""
    query: str = ""  # Original user query

    message: list[dict] = Field(default_factory=list)  # Messages used to produce final answer
    message_token_count: int = 0  # Token cost from messages
    message_unit_price: float = 0  # Unit price
    message_price_unit: float = 0  # Price unit

    answer: str = ""  # Final answer generated by the agent
    answer_token_count: int = 0  # Token count for the answer
    answer_unit_price: float = 0  # Unit price
    answer_price_unit: float = 0  # Price unit

    total_token_count: int = 0  # Total token consumption
    total_price: float = 0  # Total cost
    latency: float = 0  # Total latency

    status: str = MessageStatus.NORMAL  # Message status
    error: str = ""  # Error message if failed

    agent_thoughts: list[AgentThought] = Field(default_factory=list)  # Reasoning steps used to produce the answer
